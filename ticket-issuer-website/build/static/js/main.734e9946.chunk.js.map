{"version":3,"sources":["../../../src/Attestation/AlgorithmIdentifier.js","../../../src/Attestation/PublicKeyInfo.js","../../../src/negotiator/index.js","../../../src/Attestation/SignedDevonTicket.js","Card/index.js","App.js","reportWebVitals.js","index.js"],"names":["AlgorithmIdentifier","source","TypeError","ArrayBuffer","asn1","fromBER","this","fromSchema","result","algorithmId","getParametersValue","algorithmParams","defaultValues","schema","clearProps","compareSchema","names","algorithmIdentifier","verified","Error","algorithm","valueBlock","toString","params","outputArray","push","ObjectIdentifier","value","asn1js","Any","Sequence","object","toJSON","JSON","stringify","memberName","memberValue","parameters","name","blockName","optional","PublicKeyInfo","signatureAlgorithm","publicKey","BitString","getTokenConfig","tokenName","attestationOrigin","tokenOrigin","tokenUrlName","tokenSecretName","unsignedTokenDataName","tokenIdName","tokenParser","SignedDevconTicket","localStorageItemName","localStorageEthKeyItemName","Negotiator","filter","options","console","log","XMLconfig","queuedCommand","tokensOrigin","debug","hideTokensIframe","addTokenIframe","hasOwnProperty","isTokenOriginWebsite","currentURL","URL","window","location","href","tokensOriginURL","origin","readMagicUrl","attachPostMessageListener","event","data","iframeCommand","remove","tokenEvent","Event","document","body","dispatchEvent","parent","listenForParentMessages","bind","referrer","postMessage","iframeData","a","ethereum","request","method","userAddresses","length","message","connectMetamaskAndGetAddress","provider","ethers","providers","Web3Provider","signer","getSigner","signMessage","magicLink","iframe","createElement","src","style","width","height","opacity","appendChild","parentCommand","parentData","command","Authenticator","rawTokenData","getRawToken","base64ticket","token","ticketSecret","secret","authenticator","tokenObj","ticketBlob","id","email","magic_link","getAuthenticationBlob","res","useToken","success","returnTokensToParent","tokensOutput","readTokens","noTokens","decodedTokens","decodeTokens","tokens","filteredTokens","filterTokens","urlParams","URLSearchParams","search","tokenFromQuery","get","secretFromQuery","idFromQuery","isNewQueryTicket","map","tokenData","localStorage","setItem","Object","keys","filterKeys","forEach","fitFilter","key","o1","o2","p","storageTickets","getItem","output","parse","item","e","callBack","unsignedToken","rawTokens","decodedToken","base64ToUint8array","buffer","decodedTokenData","compareObjects","tokenIframeWrap","display","detachPostMessageListener","listenForIframeMessages","negotiateCallback","signCallback","unEndPoint","Promise","resolve","reject","_authenticate","proof","error","useEthKey","status","getChallengeSigned","validateUseEthKey","validateResult","toLowerCase","createIframe","endPoint","fetch","cache","headers","redirect","referrerPolicy","response","json","address","ethKey","expiry","Date","now","storageEthKeys","ethKeys","ethKeyIsValid","signNewChallenge","getUnpredictableNumber","UN","number","randomness","domain","expiration","messageToSign","signMessageWithBrowserWallet","signature","msgHash","utils","hashMessage","msgHashBytes","arrayify","recoveredAddress","recoverAddress","_negotiate","maxWidth","background","iframeWrap","setAttribute","base64str","split","join","Buffer","Uint8Array","from","atob","c","charCodeAt","listener","addEventListener","attachEvent","removeEventListener","detachEvent","DevconTicket","devconId","ticketId","ticketClass","_valueHex","bigInt","bufferToHexCodes","Utf8String","Integer","ticketEncoded","startsWith","searchParams","ticket","commitment","publicKeyInfo","signatureValue","valueBeforeDecode","valueHex","OctetString","MediaCard","tokenInstance","className","Typography","variant","component","color","mockTicketData","App","useState","setTokens","negotiator","useEffect","negotiate","devconData","openTicketInIframe","preventDefault","addTokenThroughIframe","index","mockTicket","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.734e9946.chunk.js","sourcesContent":["import { Any, compareSchema, ObjectIdentifier, Sequence } from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class AlgorithmIdentifier {\n  //**********************************************************************************\n  /**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.algorithmId = getParametersValue(\n          source,\n          \"algorithmId\"\n      );\n\n      if (\"algorithmParams\" in source)\n        /**\n         * @type {Object}\n         * @desc Any algorithm source\n         */\n        this.algorithmParams = getParametersValue(\n            source,\n            \"algorithmParams\",\n            AlgorithmIdentifier.defaultValues(\"algorithmParams\")\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n   /* FIXME: algorithmParams is options hence not removed and we need to complete this with all parameters with their default value covered here.\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmParams\":\n        return new Any();\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * AlgorithmIdentifier  ::=  Sequence  {\n   *    algorithm               OBJECT IDENTIFIER,\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n     * @property {string} algorithmParams Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [\n        new ObjectIdentifier({ name: names.algorithmIdentifier || \"algorithm\" }),\n        new Any({ name: names.algorithmParams || \"parameters\", optional: true }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"params\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      AlgorithmIdentifier.schema({\n        names: {\n          algorithmIdentifier: \"algorithm\",\n          algorithmParams: \"params\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n\n    //region Get internal properties from parsed schema\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      outputArray.push(this.algorithmParams);\n    //endregion\n\n    //region Construct and return new ASN.1 schema for this object\n    return new Sequence({\n      value: outputArray,\n    });\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId,\n    };\n\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      object.algorithmParams = this.algorithmParams.toJSON();\n\n    return object;\n  }\n  //**********************************************************************************\n  /**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false)\n      return false;\n    //endregion\n\n    //region Check \"algorithm_id\"\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n    //endregion\n\n    //region Check \"algorithm_params\"\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier)\n        return (\n          JSON.stringify(this.algorithmParams) ===\n          JSON.stringify(algorithmIdentifier.algorithmParams)\n        );\n\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false;\n    //endregion\n\n    return true;\n  }\n  //**********************************************************************************\n}\n//**************************************************************************************\n","import {\n  BitString,\n  compareSchema,\n  Sequence,\n  fromBER,  \n} from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\nimport AlgorithmIdentifier from \"./AlgorithmIdentifier.js\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class PublicKeyInfo {\n  //**********************************************************************************\n  /**\n   * Constructor for PublicKeyInfo class\n   * @param {Object} [source={}]\n   * @param {Object} [source.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n      throw new TypeError(\"Not accepting string. For base64, convert to ArrayBuffer.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      /**\n       * @type {string}\n       * @desc ObjectIdentifier for algorithm (string representation)\n       */\n      this.signatureAlgorithm = getParametersValue(\n          source,\n          \"signatureAlgorithm\"\n      );\n\t  this.publicKey = getParametersValue(\n          source,\n          \"publicKey\"\n      );\n    }\n  }\n \n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * PublicKeyInfo  ::=  Sequence  {\n   *    signatureAlgorithm               AlgorithmIdentifier,\n   *    publicKey              BIT-STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} signatureAlgorithm ObjectIdentifier for the algorithm\n     * @property {string} publicKey Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: true,\n      value: [\n\t\tAlgorithmIdentifier.schema(\n\t\t\tnames.signatureAlgorithm || {\n\t\t\t  names: {\n\t\t\t\tblockName: \"signatureAlgorithm\",\n\t\t\t  },\n\t\t\t}\n\t\t),\n        new BitString({ name: \"publicKey\"}),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"signatureAlgorithm\", \"publicKey\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      PublicKeyInfo.schema({\n        names: {\n          signatureAlgorithm: \"signatureAlgorithm\",\n          publicKey: \"publicKey\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n  }\n}\n//**************************************************************************************\n","import { SignedDevconTicket } from './../Attestation/SignedDevonTicket';\nimport { ethers } from \"ethers\";\n\nconst getTokenConfig = (tokenName) => {\n  let XMLconfig = {};\n  // this will come from a lookup table at a later stage.\n  // commented for now so breaking changes are not caused.\n  // if (tokenName === \"devcon-ticket\") {\n    XMLconfig = {\n      attestationOrigin: \"https://stage.attestation.id\",\n      tokenOrigin: \"https://devcontickets.herokuapp.com/outlet/\",\n      tokenUrlName: 'ticket',\n      tokenSecretName: 'secret',\n      unsignedTokenDataName: 'ticket',\n      tokenIdName: 'id',\n      tokenParser: SignedDevconTicket,\n      localStorageItemName: 'dcTokens',\n      localStorageEthKeyItemName: 'dcEthKeys',\n    };\n  // } else {\n    // console.log(\"Negotiator: missing token script for this token\");\n  // }\n  return XMLconfig;\n}\n\nexport class Negotiator {\n\n  constructor(filter = {}, tokenName, options = {}) {\n\n    if (!tokenName) console.log(\"Negotiator: tokenName is a required parameter\");\n\n    // The XML config is used to define the token configuration.\n    // This includes how the ticket will confirm its vailidity and the origin\n    // of where the ticket was issued from.\n    let XMLconfig = getTokenConfig(tokenName);\n    // TODO annotate the usage of variables below.\n    this.queuedCommand = false;\n    this.filter = filter;\n    //\n    this.tokensOrigin = XMLconfig.tokenOrigin;\n    this.debug = 0;\n    this.hideTokensIframe = 1;\n    this.tokenOrigin = XMLconfig.tokenOrigin;\n    this.attestationOrigin = XMLconfig.attestationOrigin;\n    this.tokenUrlName = XMLconfig.tokenUrlName;\n    this.tokenSecretName = XMLconfig.tokenSecretName;\n    this.tokenIdName = XMLconfig.tokenIdName;\n    this.unsignedTokenDataName = XMLconfig.unsignedTokenDataName;\n    this.tokenParser = XMLconfig.tokenParser;\n    this.localStorageItemName = XMLconfig.localStorageItemName;\n    this.localStorageEthKeyItemName = XMLconfig.localStorageEthKeyItemName;\n    this.addTokenIframe = null;\n\n    if (options.hasOwnProperty('debug')) this.debug = options.debug;\n    if (options.hasOwnProperty('attestationOrigin')) this.attestationOrigin = options.attestationOrigin;\n    if (options.hasOwnProperty('tokenOrigin')) this.tokenOrigin = options.tokenOrigin;\n\n    this.isTokenOriginWebsite = false;\n\n    if (this.attestationOrigin) {\n      // if attestationOrigin filled then token need attestaion\n      let currentURL = new URL(window.location.href);\n      let tokensOriginURL = new URL(this.tokensOrigin);\n\n      if (currentURL.origin === tokensOriginURL) {\n        // its tokens website, where tokens saved in localStorage\n        // lets chech url params and save token data to the local storage\n        this.isTokenOriginWebsite = true;\n        this.readMagicUrl();\n      }\n\n      this.attachPostMessageListener(event => {\n        if (event.origin !== tokensOriginURL.origin) {\n          return;\n        }\n        if (event.data.iframeCommand && event.data.iframeCommand == \"closeMe\" && this.addTokenIframe) {\n          this.addTokenIframe.remove();\n          const tokenEvent = new Event('newTokenAdded');\n          document.body.dispatchEvent(tokenEvent);\n        }\n\n      })\n\n    }\n\n    // do we inside iframe?\n    if (window !== window.parent) {\n      this.debug && console.log('negotiator: its iframe, lets return tokens to the parent');\n\n      // its iframe, listen for requests\n      this.attachPostMessageListener(this.listenForParentMessages.bind(this))\n\n      // send ready message to start interaction\n      let referrer = new URL(document.referrer);\n      window.parent.postMessage({ iframeCommand: \"iframeReady\", iframeData: '' }, referrer.origin);\n    }\n\n  }\n\n  async connectMetamaskAndGetAddress() {\n\n    if (!window.ethereum) {\n      throw new Error('Please install metamask before.');\n    }\n\n    // const userAddresses = await window.ethereum.request({ method: 'eth_accounts' });\n    const userAddresses = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    if (!userAddresses || !userAddresses.length) {\n      throw new Error(\"Active Wallet required\");\n    }\n\n    return userAddresses[0];\n  }\n\n  async signMessageWithBrowserWallet(message) {\n    await this.connectMetamaskAndGetAddress();\n\n    let provider = new ethers.providers.Web3Provider(window.ethereum);\n    let signer = provider.getSigner();\n    return await signer.signMessage(message);\n  }\n\n  addTokenThroughIframe(magicLink) {\n    console.log('createTokenIframe fired for : ' + magicLink);\n    // open iframe and request tokens\n    // this.attachPostMessageListener(this.listenForIframeMessages.bind(this));\n\n    const iframe = document.createElement('iframe');\n    this.addTokenIframe = iframe;\n    iframe.src = magicLink;\n    iframe.style.width = '1px';\n    iframe.style.height = '1px';\n    iframe.style.opacity = 0;\n    // let iframeWrap = document.createElement('div');\n    // this.tokenIframeWrap = iframeWrap;\n    // iframeWrap.setAttribute('style', 'width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa');\n    // iframeWrap.appendChild(iframe);\n    document.body.appendChild(iframe);\n  }\n\n  listenForParentMessages(event) {\n\n    // listen only parent\n    let referrer = new URL(document.referrer);\n    if (event.origin !== referrer.origin) {\n      return;\n    }\n\n    // console.log('iframe: event = ', event.data);\n\n    // parentCommand+parentData required for interaction\n    if (\n      typeof event.data.parentCommand === \"undefined\"\n      || typeof event.data.parentData === \"undefined\"\n    ) {\n      return;\n    }\n\n    // parentCommand contain command code\n    let command = event.data.parentCommand;\n\n    // parentData contains command content (token to sign or empty object)\n    let data = event.data.parentData;\n\n    console.log('iframe: command, data = ', command, data);\n\n    switch (command) {\n      case \"signToken\":\n        // we receive decoded token, we have to find appropriate raw token\n        if (typeof window.Authenticator === \"undefined\") {\n          console.log('Authenticator not defined.');\n          return;\n        }\n\n        let rawTokenData = this.getRawToken(data);\n\n        let base64ticket = rawTokenData.token;\n        let ticketSecret = rawTokenData.secret;\n        this.authenticator = new Authenticator(this);\n\n        let tokenObj = {\n          ticketBlob: base64ticket,\n          ticketSecret: ticketSecret,\n          attestationOrigin: this.attestationOrigin,\n        };\n        if (rawTokenData && rawTokenData.id) tokenObj.email = rawTokenData.id;\n        if (rawTokenData && rawTokenData.magic_link) tokenObj.magicLink = rawTokenData.magic_link;\n\n        this.authenticator.getAuthenticationBlob(tokenObj,\n          res => {\n            console.log('sign result:', res);\n            window.parent.postMessage({ iframeCommand: \"useTokenData\", iframeData: { useToken: res, message: '', success: !!res } }, referrer.origin);\n          });\n        break;\n      case \"tokensList\":\n        // TODO update\n        // console.log('let return tokens');\n        this.returnTokensToParent();\n        break;\n\n      default:\n    }\n  }\n\n  commandDisplayIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'show' }, referrer.origin);\n  }\n\n  commandHideIframe() {\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"iframeWrap\", iframeData: 'hide' }, referrer.origin);\n  }\n\n  returnTokensToParent() {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n      let filteredTokens = this.filterTokens(decodedTokens);\n      tokensOutput.tokens = filteredTokens;\n    }\n    let referrer = new URL(document.referrer);\n    window.parent.postMessage({ iframeCommand: \"tokensData\", iframeData: tokensOutput }, referrer.origin);\n  }\n\n  readMagicUrl() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tokenFromQuery = urlParams.get(this.tokenUrlName);\n    const secretFromQuery = urlParams.get(this.tokenSecretName);\n    const idFromQuery = urlParams.get(this.tokenIdName);\n\n    if (!(tokenFromQuery && secretFromQuery)) {\n      return;\n    }\n\n    // Get the current Storage Tokens\n    let tokensOutput = this.readTokens();\n    let tokens = [];\n\n    let isNewQueryTicket = true;\n\n    if (!tokensOutput.noTokens) {\n      // Build new list of tickets from current and query ticket { ticket, secret }\n      tokens = tokensOutput.tokens;\n\n      tokens.map(tokenData => {\n        if (tokenData.token === tokenFromQuery) {\n          isNewQueryTicket = false;\n        }\n      });\n\n    }\n\n    // Add ticket if new\n    // if (isNewQueryTicket && tokenFromQuery && secretFromQuery) {\n    if (isNewQueryTicket) {\n      tokens.push({\n        token: tokenFromQuery,\n        secret: secretFromQuery,\n        id: idFromQuery,\n        magic_link: window.location.href\n      }); // new raw object\n    }\n    // Set New tokens list raw only, websters will be decoded each time\n    localStorage.setItem(this.localStorageItemName, JSON.stringify(tokens));\n\n    if (window !== window.parent) {\n      this.debug && console.log('negotiator: its iframe, lets close it');\n\n      // send ready message to start interaction\n      let referrer = new URL(document.referrer);\n      window.parent.postMessage({ iframeCommand: \"closeMe\" }, referrer.origin);\n    }\n  }\n\n  /*\n    * Return token objects satisfying the current negotiator's requirements\n    */\n  filterTokens(decodedTokens, filter = {}) {\n    if (Object.keys(filter).length == 0) {\n      filter = this.filter;\n    }\n    let res = [];\n    if (\n      decodedTokens.length\n      && typeof filter === \"object\"\n      && Object.keys(filter).length\n    ) {\n      let filterKeys = Object.keys(filter);\n      decodedTokens.forEach(token => {\n        let fitFilter = 1;\n        this.debug && console.log('test token:', token);\n        filterKeys.forEach(key => {\n          if (token[key].toString() != filter[key].toString()) fitFilter = 0;\n        })\n        if (fitFilter) {\n          res.push(token);\n          this.debug && console.log('token fits:', token);\n        }\n      })\n      return res;\n    } else {\n      return decodedTokens;\n    }\n  }\n\n  compareObjects(o1, o2) {\n    for (var p in o1) {\n      if (o1.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    for (var p in o2) {\n      if (o2.hasOwnProperty(p)) {\n        if (o1[p].toString() !== o2[p].toString()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  // read tokens from local storage and return as object {tokens: [], noTokens: boolean, success: boolean}\n  readTokens() {\n    const storageTickets = localStorage.getItem(this.localStorageItemName);\n    let tokens = [];\n    let output = { tokens: [], noTokens: true, success: true };\n    try {\n      if (storageTickets && storageTickets.length) {\n        // Build new list of tickets from current and query ticket { ticket, secret }\n        tokens = JSON.parse(storageTickets);\n        if (tokens.length !== 0) {\n\n          // output.tokens = tokens;\n          tokens.forEach(item => {\n            if (item.token && item.secret) {\n              output.tokens.push(item)\n              // output.tokens.push({\n              //     token: item.token,\n              //     secret: item.secret\n              // })\n            }\n          })\n        }\n        if (output.tokens.length) {\n          output.noTokens = false;\n        }\n      }\n    } catch (e) {\n      console.log('Cant parse tokens in LocalStorage');\n      if (typeof callBack === \"function\") {\n        output.success = false;\n      }\n    }\n    return output;\n  }\n\n  getRawToken(unsignedToken) {\n    let tokensOutput = this.readTokens();\n    if (tokensOutput.success && !tokensOutput.noTokens) {\n      let rawTokens = tokensOutput.tokens;\n\n      let token = false;\n\n      if (rawTokens.length) {\n        rawTokens.forEach(tokenData => {\n          if (tokenData.token) {\n\n            let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n            if (decodedToken && decodedToken[this.unsignedTokenDataName]) {\n              let decodedTokenData = decodedToken[this.unsignedTokenDataName];\n\n              if (this.compareObjects(decodedTokenData, unsignedToken)) {\n                token = tokenData;\n              }\n\n            }\n          } else {\n            console.log('empty token data received');\n          }\n\n        })\n      }\n\n      return token;\n    }\n  }\n\n  listenForIframeMessages(event) {\n\n    // console.log('listenForIframeMessages fired');\n\n    let tokensOriginURL = new URL(this.tokensOrigin);\n\n    // listen only tokensOriginURL\n    if (event.origin !== tokensOriginURL.origin) {\n      return;\n    }\n\n    // console.log('parent: event = ', event.data);\n\n    // iframeCommand required for interaction\n    if (\n      typeof event.data.iframeCommand === \"undefined\"\n      || typeof event.data.iframeData === \"undefined\"\n    ) {\n      return;\n    }\n\n    // iframeCommand contain command code\n\n    let command = event.data.iframeCommand;\n\n    // iframeData contains command content (tokens data, useToken , hide/display iframe)\n    let data = event.data.iframeData;\n\n    console.log('parent: command, data = ', command, data);\n\n    switch (command) {\n      case \"iframeWrap\":\n        if (data == \"show\") {\n          this.tokenIframeWrap.style.display = 'block';\n        } else if (data == \"hide\") {\n          this.tokenIframeWrap.style.display = 'none';\n        }\n        break;\n      case \"tokensData\":\n        // tokens received, disable listener\n        this.detachPostMessageListener(this.listenForIframeMessages);\n        // TODO remove iframeWraper\n        this.tokenIframeWrap.remove();\n\n        if (data.success && !data.noTokens) {\n          data.tokens = this.filterTokens(data.tokens);\n        }\n        this.negotiateCallback(data);\n        break;\n\n      case \"useTokenData\":\n\n        this.tokenIframeWrap.remove();\n\n        this.signCallback && this.signCallback(data);\n        this.signCallback = false;\n        break;\n\n      case \"iframeReady\":\n        if (event && event.source) {\n          event.source.postMessage(this.queuedCommand, event.origin);\n          this.queuedCommand = '';\n        }\n\n        break;\n\n      default:\n\n    }\n  }\n\n  authenticate({unsignedToken, unEndPoint}) {\n    return new Promise(async (resolve, reject) => {\n      await this._authenticate(unsignedToken, unEndPoint, (proof, error) => {\n        if (!proof || !this.useEthKey) return reject(error);\n        resolve({ proof, useEthKey: this.useEthKey, status: true });\n      })\n    })\n  }\n\n\n  async _authenticate(unsignedToken, unEndPoint, signCallback) {\n    let useEthKey;\n    try {\n      useEthKey = await this.getChallengeSigned(unEndPoint);\n      const validateResult = await this.validateUseEthKey(unEndPoint, useEthKey);\n      let walletAddress = await this.connectMetamaskAndGetAddress();\n      if (walletAddress.toLowerCase() !== validateResult.toLowerCase()) {\n        throw new Error('useEthKey validation failed.');\n      }\n    } catch (e) {\n      signCallback(null, e);\n      return;\n    }\n\n    this.useEthKey = useEthKey;\n\n    this.signCallback = signCallback;\n    // open iframe and request tokens\n    this.queuedCommand = { parentCommand: 'signToken', parentData: unsignedToken };\n    this.createIframe();\n  }\n\n  async validateUseEthKey(endPoint, data){\n    try {\n      const response = await fetch(endPoint, {\n        method: 'POST', // *GET, POST, PUT, DELETE, etc.\n        //mode: 'cors', // no-cors, *cors, same-origin\n        cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached\n        //credentials: 'same-origin', // include, *same-origin, omit\n        headers: {\n          'Content-Type': 'application/json'\n          // 'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        redirect: 'follow', // manual, *follow, error\n        referrerPolicy: 'no-referrer', // no-referrer, *client\n        body: JSON.stringify(data) // body data type must match \"Content-Type\" header\n      });\n      const json = await response.json();\n      return json.address;\n    } catch (e) {\n      console.log(e);\n      return '';\n    }\n  }\n\n  async getUnpredictableNumber(endPoint) {\n    try {\n      const response = await fetch(endPoint);\n      const json = await response.json();\n      json.success = true;\n      return json;\n    } catch (e) {\n      console.log(e);\n      return {\n        success: false,\n        message: \"UN request failed\"\n      }\n    }\n  }\n\n  ethKeyIsValid(ethKey) {\n    if (ethKey.expiry < Date.now()) return false;\n    return true;\n  }\n\n  async getChallengeSigned(unEndPoint) {\n\n    const storageEthKeys = localStorage.getItem(this.localStorageEthKeyItemName);\n    let ethKeys;\n\n    if (storageEthKeys && storageEthKeys.length) {\n      ethKeys = JSON.parse(storageEthKeys);\n    } else {\n      ethKeys = {};\n    }\n\n    try {\n      let address = await this.connectMetamaskAndGetAddress();\n      address = address.toLowerCase();\n\n      let useEthKey;\n\n      if (ethKeys && ethKeys[address] && !this.ethKeyIsValid(ethKeys[address])) {\n        console.log('remove invalid useEthKey');\n        delete ethKeys[address];\n      }\n\n      if (ethKeys && ethKeys[address]) {\n        useEthKey = ethKeys[address];\n      } else {\n        useEthKey = await this.signNewChallenge(unEndPoint);\n        if (useEthKey) {\n          ethKeys[useEthKey.address.toLowerCase()] = useEthKey;\n          localStorage.setItem(this.localStorageEthKeyItemName, JSON.stringify(ethKeys));\n        }\n      }\n      return useEthKey;\n\n    } catch (e) {\n      throw new Error(e.message);\n    }\n  }\n\n  async signNewChallenge(unEndPoint) {\n    let res = await this.getUnpredictableNumber(unEndPoint);\n\n    console.log(res);\n    const { number:UN, randomness, domain, expiration:expiry, messageToSign } = res;\n\n    let signature = await this.signMessageWithBrowserWallet(messageToSign);\n    const msgHash = ethers.utils.hashMessage(messageToSign);\n    const msgHashBytes = ethers.utils.arrayify(msgHash);\n\n    const recoveredAddress = ethers.utils.recoverAddress(msgHashBytes, signature);\n\n    return {\n      address: recoveredAddress,\n      expiry,\n      domain,\n      randomness,\n      signature,\n      UN\n    };\n  }\n\n  negotiate() {\n    return new Promise((resolve, reject) => {\n      this._negotiate((tokens) => {\n        if (!tokens) return reject(false)\n        resolve(tokens);\n      })\n    })\n  }\n  \n  getTokenInstances() {\n    return new Promise((resolve, reject) => {\n      this._negotiate((tokens) => {\n        if (!tokens) return reject(false)\n        resolve(tokens);\n      })\n    })\n  }\n\n  _negotiate(callBack) {\n\n    this.negotiateCallback = callBack;\n\n    if (this.attestationOrigin) {\n\n      console.log('attestationOrigin', this.attestationOrigin);\n\n      if (window.location.href === this.tokensOrigin) {\n        // just read an return tokens\n        let tokensOutput = this.readTokens();\n        if (tokensOutput.success && !tokensOutput.noTokens) {\n          let decodedTokens = this.decodeTokens(tokensOutput.tokens);\n          let filteredTokens = this.filterTokens(decodedTokens);\n          tokensOutput.tokens = filteredTokens;\n          this.negotiateCallback(tokensOutput);\n        }\n      } else {\n        this.queuedCommand = { parentCommand: 'tokensList', parentData: '' };\n        this.createIframe()\n      }\n    } else {\n      console.log('no attestationOrigin...');\n      // TODO test token against blockchain and show tokens as usual view\n    }\n  }\n\n  createIframe() {\n    console.log('createIframe fired');\n    // open iframe and request tokens\n    this.attachPostMessageListener(this.listenForIframeMessages.bind(this));\n\n    const iframe = document.createElement('iframe');\n    this.iframe = iframe;\n    iframe.src = this.tokensOrigin;\n    iframe.style.width = '800px';\n    iframe.style.height = '700px';\n    iframe.style.maxWidth = '100%';\n    iframe.style.background = '#fff';\n    let iframeWrap = document.createElement('div');\n    this.tokenIframeWrap = iframeWrap;\n    iframeWrap.setAttribute('style', 'width:100%; min-height: 100vh; position: fixed; align-items: center; justify-content: center; display: none; top: 0; left: 0; background: #fffa');\n    iframeWrap.appendChild(iframe);\n    document.body.appendChild(iframeWrap);\n  }\n\n  base64ToUint8array(base64str) {\n    // decode base64url to base64. it will do nothing for base64\n    base64str = base64str.split('-').join('+')\n      .split('_').join('/')\n      .split('.').join('=');\n    let res;\n\n    if (typeof Buffer !== 'undefined') {\n      res = Uint8Array.from(Buffer.from(base64str, 'base64'));\n    } else {\n      res = Uint8Array.from(atob(base64str), c => c.charCodeAt(0));\n    }\n    return res;\n  }\n\n  decodeTokens(rawTokens) {\n    if (this.debug) {\n      console.log('decodeTokens fired');\n      console.log(rawTokens);\n    }\n    let decodedTokens = [];\n    if (rawTokens.length) {\n      rawTokens.forEach(tokenData => {\n        if (tokenData.token) {\n          let decodedToken = new this.tokenParser(this.base64ToUint8array(tokenData.token).buffer);\n          if (decodedToken && decodedToken[this.unsignedTokenDataName]) decodedTokens.push(decodedToken[this.unsignedTokenDataName]);\n        } else {\n          console.log('empty token data received');\n        }\n\n      })\n    }\n    return decodedTokens;\n  }\n\n  attachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.addEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.attachEvent(\"onmessage\", listener);\n    }\n  }\n  detachPostMessageListener(listener) {\n    if (window.addEventListener) {\n      window.removeEventListener(\"message\", listener, false);\n    } else {\n      // IE8\n      window.detachEvent(\"onmessage\", listener);\n    }\n  }\n}\n","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n  fromBER, Utf8String\n} from \"asn1js\";\nimport { getParametersValue, clearProps, bufferToHexCodes } from \"pvutils\";\nimport PublicKeyInfo from \"./PublicKeyInfo.js\";\nimport { ethers } from \"ethers\";\n\nexport class DevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is CER encoded\n   */\n  constructor(source = {}) {\n    if (typeof (source) == \"string\") {\n      throw new TypeError(\"Unimplemented: Not accepting string yet.\")\n    }\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source)\n      this.fromSchema(asn1.result);\n    } else {\n      this.devconId = getParametersValue(\n          source,\n          \"devconId\"\n      );\n      this.ticketId = getParametersValue(\n          source,\n          \"ticketId\"\n      );\n      this.ticketClass = getParametersValue(\n          source,\n          \"ticketClass\"\n      );\n    }\n  }\n\n  static schema(parameters = {}) {\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"ticket\",\n      value: [\n        new Utf8String({\n          name: names.devconId || \"devconId\",\n        }),\n        new Integer({\n          name: names.ticketId || \"ticketId\",\n        }),\n        new Integer({\n          name: names.ticketClass || \"ticketClass\",\n        }),\n      ],\n    });\n  }\n\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"devconId\",\n      \"ticketId\",\n      \"ticketClass\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, DevconTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\"Object's schema was not verified against input data for DevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    if (\"devconId\" in asn1.result) {\n      this.devconId = asn1.result[\"devconId\"].valueBlock.value;\n    }\n\n    if (\"ticketId\" in asn1.result) {\n      const ticketId = asn1.result[\"ticketId\"].valueBlock._valueHex;\n      this.ticketId = bigInt(\"0x\" + bufferToHexCodes(ticketId));\n    }\n\n    if (\"ticketClass\" in asn1.result) {\n      const ticketClass = asn1.result[\"ticketClass\"].valueBlock._valueHex;\n      this.ticketClass = bigInt(\"0x\" + bufferToHexCodes(ticketClass));\n    }\n\n    //endregion\n  }\n}\n\nexport class SignedDevconTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [source={}] source is an object\n   * @param {Object} [source:ArrayBuffer] source is DER encoded\n   * @param {Object} [source:String]  source is DER encoded\n   */\n  constructor(source = {}) {\n    if (typeof(source) == \"string\") {\n\n      const ticketEncoded = (source.startsWith(\"https://\")) ?\n          (new URL(source)).searchParams.get('ticket') : source;\n      \n      let base64str = ticketEncoded\n          .split('_').join('/')\n          .split('-').join('+')\n          .split('.').join('=');\n\n      // source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      if (typeof Buffer !== 'undefined') {\n        source = Uint8Array.from(Buffer.from(base64str, 'base64')).buffer;\n      } else {\n        source = Uint8Array.from(atob(base64str), c => c.charCodeAt(0)).buffer;\n      }\n      \n    }\n\n    if (source instanceof ArrayBuffer) {\n      const asn1 = fromBER(source);\n      this.fromSchema(asn1.result);\n    } else {\n      this.ticket = new DevconTicket(source.ticket);\n\n      this.commitment = getParametersValue(\n          source,\n          \"commitment\"\n      );\n\n      // TODO: issue #75\n      // this.signatureAlgorithm = new AlgorithmIdentifier(source.signatureAlgorithm);\n\t  \n\t  this.publicKeyInfo = new PublicKeyInfo(source.publicKeyInfo)\n\n      this.signatureValue = getParametersValue(\n          source,\n          \"signatureValue\"\n      );\n    }\n  }\n\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * CertificateList  ::=  SEQUENCE  {\n   *    tbsCertList          TBSCertList,\n   *    signatureAlgorithm   AlgorithmIdentifier,\n   *    signatureValue       BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [signatureAlgorithm]\n     * @property {string} [signatureValue]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"SignedDevconTicket\",\n      value: [\n        DevconTicket.schema(parameters),\n        new OctetString({\n          name: \"commitment\",\n        }),\n        /* PublicKeyInfo is specified in schema here but not appearing in the constructed data object.\n         * This is because the underlying AlgorithmIdentifier isn't fully implemented and also\n         * that this data is not important for the 1st delivery deadline, won't be read by client anyway.\n         * TODO: add support for PublicKeyInfo https://github.com/TokenScript/attestation/issues/75\n         */\n        // new Sequence( {\n        //   name: \"publicKeyInfo\",\n        //   optional: true,\n        //   value: [\n        //     PublicKeyInfo.schema(\n        //         names.publicKeyInfo || {\n        //           names: {\n        //             blockName: \"publicKeyInfo\",\n        //           },\n        //         }\n        //     )\n        //   ]\n        // }),\n\n        new BitString({\n          name: \"signatureValue\",\n        }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"ticket\",\n      \"commitment\",\n      // TODO: #75\n\t  \"publicKeyInfo\",\n      \"signatureValue\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, SignedDevconTicket.schema());\n\n    if (asn1.verified === false)\n\t\tthrow new Error(\"Object's schema was not verified against input data for SignedDevconTicket\");\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n\n    this.ticket = new DevconTicket(asn1.result.ticket.valueBeforeDecode)\n\n    if (\"commitment\" in asn1.result)\n      this.commitment = asn1.result[\"commitment\"].valueBlock.valueHex;\n\n    // TODO: issue #75\n    // this.signatureAlgorithm = new AlgorithmIdentifier(asn1.result.signatureAlgorithm);\n\tthis.publicKeyInfo = new PublicKeyInfo({\n      schema: asn1.result.publicKeyInfo,\n    });\n\n    const signatureValue = asn1.result.signatureValue;\n    this.signatureValue = signatureValue.valueBlock.valueHex;    //endregion\n  }\n}\n","import React from 'react';\nimport Typography from '@material-ui/core/Typography';\nimport './Card.css';\n\nfunction MediaCard({ tokenInstance }) {\n\n  // New Data Structure:\n  const { ticketClass, ticketId, devconId } = tokenInstance;\n  return (\n    <div className=\"ticketContainer\">\n      <div className=\"ticketDetails\">\n        <Typography className=\"ticketClass\" variant=\"h5\" component=\"h2\">\n          {ticketClass.toString()}\n        </Typography>\n        <Typography className=\"ticketId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          {ticketId && ticketId.toString()}\n        </Typography>\n        <Typography className=\"devconId\" variant=\"body2\" color=\"textSecondary\" component=\"p\">\n          Devcon ID: {devconId && devconId.toString()}\n        </Typography>\n      </div>\n      <img className=\"ticketImg\" src=\"ticket_example_image.svg\"></img>\n    </div>\n  );\n}\n\nexport default MediaCard;\n","import React, { useState, useEffect } from 'react';\nimport { Negotiator } from 'token-negotiator';\nimport Card from './Card';\nimport './App.css';\n\n// A minimal example to read tokens and render them to a view.\n\nconst mockTicketData = [\n  {\n    ticket: \"MIGWMA0MATYCBWE3ap3-AgEABEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNCAOOZKRpcE6tLBuPbfE_SmwPk2wNjbj5vpa6kkD7eqQXvBOCa0WNo8dEHKvipeUGZZEWWjJKxooB44dEYdQO70Vgc\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGXMA4MAjExAgVhN2qd_gIBAARBBCiWVcTBF25EmWQVpzVE1_-YnrvBlKn9G8f2tLQTxekGLJAAWjCQWIQzl7JkLd3LJP03zGdsHZn0ZCu3jwjiNpIDQgBbJBY1Ctlp_czUwB85yF1e5kpZ-lQ_-UZ7jaCYSFoEx028Jit1HIDLCJezKdsNn9c9IO7-HC-_r2ZLaYQ9GGrbHA==\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGTMAoMATYCAgDeAgEABEEEKJZVxMEXbkSZZBWnNUTX_5ieu8GUqf0bx_a0tBPF6QYskABaMJBYhDOXsmQt3csk_TfMZ2wdmfRkK7ePCOI2kgNCAEZYXbNmWXDsAqIc5uf7SirR-dLCMLdEVN5teFrV93VbcKE_DED8c6jtFQ5LH2SRXwPEtXZqWfEh1c2OHTEYqfwb\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n  {\n    ticket: \"MIGSMAkMATECAQECAQAEQQQollXEwRduRJlkFac1RNf_mJ67wZSp_RvH9rS0E8XpBiyQAFowkFiEM5eyZC3dyyT9N8xnbB2Z9GQrt48I4jaSA0IAOf4d0N9shWfPIgRXZPdBRhlRyIARDT0tJwNWYwy2ILVKnIy-qPzFsgdI6sZHm1OY6UsJKuDlp0A7EMC8vS5YhRs=\",\n    secret:\"45845870684\",\n    id:\"mah@mah.com\"\n  },\n];\n\nfunction App() {\n\n  // local react state for tokens\n  let [tokens, setTokens] = useState([]);\n  \n  // create configuration and instance of Negotiator.\n  const filter = {};\n  const token = \"devcon-ticket\";\n  const options = {};\n  const negotiator = new Negotiator(filter, token, options);\n  \n  useEffect(async () => {\n    // retrieve existing tokens on initialisation of this component\n    const devconData = await negotiator.negotiate();\n    if(devconData.success) setTokens(devconData.tokens);\n  }, []);\n\n  const openTicketInIframe = async ({event, ticket, secret, id}) => {\n    event.preventDefault();\n    // add token through magic link\n    const magicLink = `https://devcontickets.herokuapp.com/outlet/?ticket=${ticket}&secret=${secret}&id=${id}`;\n    negotiator.addTokenThroughIframe(magicLink); \n    // apply token to react state\n    const devconData = await negotiator.negotiate();\n    if(devconData.success) setTokens(devconData.tokens);\n  }\n\n  return (\n    <main>\n      <a href=\"/\"><img className=\"logo\" src=\"./devcon.svg\"></img></a>\n      <div className=\"flexCenter\">\n        <p>[DEMO Ticket Issuer Website]</p>\n      </div>\n      <div className=\"flexCenter\">\n        <img className=\"devcon_bogota\" src=\"./devcon_bogota.svg\"></img>\n      </div>\n      <div className=\"flexCenter\">\n        <p>A Devcon ticket provides access to the event and special offers between the dates X-XX for hotel bookings, travel, restaurants and more.</p>\n      </div>\n      <div className=\"flexCenter\">\n        <p>Your tickets:</p>\n      </div>\n      <div className=\"flexCenter\">\n        <div className=\"tokensWrapper\">\n          {\n            tokens && tokens.length > 0 && tokens.map((tokenInstance, index) => {\n              return <Card key={index} tokenInstance={tokenInstance} />\n            })\n          }\n          {\n            !tokens.length && <div>\n              <b>- no ticket found -</b>\n              <p>Generate ticket:</p>\n              <div className=\"ticketWrapper\">\n                {\n                  mockTicketData.map((mockTicket, index) => {\n                    return (\n                      <button key={index} className=\"makeTicket\" onClick={event => openTicketInIframe({ \n                        event,\n                        ticket: mockTicket.ticket,\n                        secret: mockTicket.secret,\n                        id: mockTicket.id\n                      })}>Create Ticket</button> \n                    )\n                  })\n                }\n              </div>\n            </div>\n          }\n        </div>\n      </div>\n    </main>\n  );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}